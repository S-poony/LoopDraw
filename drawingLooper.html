<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing Looper - Chrono Replay</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            touch-action: none;
            background-color: #121212;
            color: #f0f0f0;
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
        }
        canvas {
            cursor: crosshair;
            touch-action: none;
        }
        .ui-overlay {
            pointer-events: none;
        }
        .ui-overlay button, .ui-overlay input {
            pointer-events: auto;
        }
        .tool-btn {
            transition: all 0.2s;
        }
        .tool-btn.active {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }
    </style>
<base target="_blank">
</head>
<body class="flex flex-col h-screen">

    <!-- Interface -->
    <div class="p-4 bg-zinc-900 border-b border-zinc-800 flex items-center justify-between z-20">
        <div class="flex items-center gap-6">
            <div>
                <h1 class="font-bold text-xl text-white">Drawing Looper</h1>
                <p class="text-xs text-zinc-500">Cycle : <span id="cycleCount" class="text-blue-400">1</span> | Couleur : <span id="currentColorBox" class="inline-block w-3 h-3 rounded-full align-middle"></span></p>
            </div>

            <div class="flex flex-col">
                <label class="text-[10px] uppercase text-zinc-500 font-bold">Durée du cycle</label>
                <div class="flex items-center gap-2">
                    <input type="range" id="durationSlider" min="5" max="60" value="30" class="w-24">
                    <span id="durationVal" class="text-sm font-mono">30s</span>
                </div>
            </div>
        </div>

        <div class="flex items-center gap-4">
            <!-- Tools -->
            <div class="flex items-center gap-2 bg-zinc-800 rounded-lg p-1">
                <button id="penBtn" class="tool-btn active bg-zinc-700 hover:bg-zinc-600 text-white px-3 py-1.5 rounded text-sm flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/></svg>
                    Pen
                </button>
                <button id="eraserBtn" class="tool-btn bg-zinc-800 hover:bg-zinc-700 text-zinc-300 hover:text-white px-3 py-1.5 rounded text-sm flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg>
                    Eraser
                </button>
            </div>

            <!-- Onion Skin Toggle -->
            <button id="onionBtn" class="bg-zinc-800 hover:bg-zinc-700 text-zinc-300 hover:text-white px-3 py-2 rounded-lg text-sm transition-colors flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a9 9 0 1 0 9 9c0-.46-.04-.92-.1-1.36a5.389 5.389 0 0 1-4.4 2.26 5.403 5.403 0 0 1-3.14-9.8c-.61-.13-1.24-.2-1.36-.1z"/></svg>
                <span id="onionText">Onion Skin: Off</span>
            </button>

            <button id="clearBtn" class="bg-zinc-800 hover:bg-red-900 text-zinc-300 hover:text-white px-4 py-2 rounded-lg text-sm transition-colors">Tout effacer</button>
            <div class="flex flex-col items-end">
                <div class="w-48 h-3 bg-zinc-800 rounded-full overflow-hidden border border-zinc-700">
                    <div id="progressBar" class="h-full bg-blue-500 w-0 transition-all duration-100"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Zone de dessin -->
    <div class="relative flex-grow bg-white overflow-hidden">
        <!-- Onion skin: STATIC snapshot of all previous cycles (fully drawn) -->
        <canvas id="onionCanvas" class="absolute top-0 left-0 w-full h-full pointer-events-none" style="opacity: 0; transition: opacity 0.3s;"></canvas>
        <!-- Replay des cycles précédents (animated based on time) -->
        <canvas id="replayCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
        <!-- Dessin en cours -->
        <canvas id="activeCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
    </div>

    <script>
        const activeCanvas = document.getElementById('activeCanvas');
        const replayCanvas = document.getElementById('replayCanvas');
        const onionCanvas = document.getElementById('onionCanvas');
        const activeCtx = activeCanvas.getContext('2d');
        const replayCtx = replayCanvas.getContext('2d');
        const onionCtx = onionCanvas.getContext('2d');

        const durationSlider = document.getElementById('durationSlider');
        const durationVal = document.getElementById('durationVal');
        const progressBar = document.getElementById('progressBar');
        const cycleCountEl = document.getElementById('cycleCount');
        const colorBox = document.getElementById('currentColorBox');
        const clearBtn = document.getElementById('clearBtn');
        const penBtn = document.getElementById('penBtn');
        const eraserBtn = document.getElementById('eraserBtn');
        const onionBtn = document.getElementById('onionBtn');
        const onionText = document.getElementById('onionText');

        // État de l'application
        let allStrokes = []; // [{ color: string, isEraser: boolean, points: [{x, y, t}] }]
        let currentStroke = null;
        let isDrawing = false;

        let cycleDuration = 30000; // 30s
        let startTime = Date.now();
        let currentCycleIndex = 1;
        let currentColor = '#000000';

        // Outils
        let currentTool = 'pen'; // 'pen' ou 'eraser'
        let isOnionSkinEnabled = false;

        // Couleurs vives pour bien distinguer les cycles
        const palette = [
            '#2563eb', '#dc2626', '#16a34a', '#d97706', 
            '#7c3aed', '#db2777', '#0891b2', '#4f46e5'
        ];

        function getRandomColor() {
            return palette[Math.floor(Math.random() * palette.length)];
        }

        function initCycle() {
            // Update color and UI
            currentColor = getRandomColor();
            colorBox.style.backgroundColor = currentColor;
            cycleCountEl.innerText = currentCycleIndex;
            activeCtx.clearRect(0, 0, activeCanvas.width, activeCanvas.height);
            startTime = Date.now();
        }

        // Render a STATIC image of all strokes fully drawn (no time animation)
        function renderStaticSnapshot(targetCtx) {
            targetCtx.clearRect(0, 0, targetCtx.canvas.width, targetCtx.canvas.height);

            targetCtx.lineCap = 'round';
            targetCtx.lineJoin = 'round';

            allStrokes.forEach(stroke => {
                if (stroke.isEraser) return; // Skip eraser strokes for onion skin

                targetCtx.beginPath();
                targetCtx.strokeStyle = stroke.color;
                targetCtx.lineWidth = 3;

                let first = true;
                for (let i = 0; i < stroke.points.length; i++) {
                    const p = stroke.points[i];
                    if (first) {
                        targetCtx.moveTo(p.x, p.y);
                        first = false;
                    } else {
                        targetCtx.lineTo(p.x, p.y);
                    }
                }
                targetCtx.stroke();
            });
        }

        function resize() {
            // Save current content before resize
            let savedReplay = null;
            let savedOnion = null;

            if (replayCanvas.width > 0 && replayCanvas.height > 0) {
                savedReplay = document.createElement('canvas');
                savedReplay.width = replayCanvas.width;
                savedReplay.height = replayCanvas.height;
                savedReplay.getContext('2d').drawImage(replayCanvas, 0, 0);
            }

            if (onionCanvas.width > 0 && onionCanvas.height > 0 && isOnionSkinEnabled) {
                savedOnion = document.createElement('canvas');
                savedOnion.width = onionCanvas.width;
                savedOnion.height = onionCanvas.height;
                savedOnion.getContext('2d').drawImage(onionCanvas, 0, 0);
            }

            activeCanvas.width = activeCanvas.clientWidth;
            activeCanvas.height = activeCanvas.clientHeight;
            replayCanvas.width = replayCanvas.clientWidth;
            replayCanvas.height = replayCanvas.clientHeight;
            onionCanvas.width = onionCanvas.clientWidth;
            onionCanvas.height = onionCanvas.clientHeight;

            // Restore content after resize
            if (savedReplay) {
                replayCtx.drawImage(savedReplay, 0, 0);
            }
            if (savedOnion) {
                onionCtx.drawImage(savedOnion, 0, 0);
            }
        }

        window.addEventListener('resize', resize);
        resize();

        // --- Outils ---

        function setTool(tool) {
            currentTool = tool;
            if (tool === 'pen') {
                penBtn.classList.add('active', 'bg-zinc-700');
                penBtn.classList.remove('bg-zinc-800');
                eraserBtn.classList.remove('active', 'bg-zinc-700');
                eraserBtn.classList.add('bg-zinc-800');
                activeCanvas.style.cursor = 'crosshair';
            } else {
                eraserBtn.classList.add('active', 'bg-zinc-700');
                eraserBtn.classList.remove('bg-zinc-800');
                penBtn.classList.remove('active', 'bg-zinc-700');
                penBtn.classList.add('bg-zinc-800');
                activeCanvas.style.cursor = 'cell';
            }
        }

        penBtn.addEventListener('click', () => setTool('pen'));
        eraserBtn.addEventListener('click', () => setTool('eraser'));

        // --- Onion Skin ---

        onionBtn.addEventListener('click', () => {
            isOnionSkinEnabled = !isOnionSkinEnabled;
            if (isOnionSkinEnabled) {
                onionBtn.classList.add('text-blue-400');
                onionText.innerText = 'Onion Skin: On';
                onionCanvas.style.opacity = '0.2';

                // INSTANT: Render static snapshot of all previous cycles immediately
                if (allStrokes.length > 0) {
                    renderStaticSnapshot(onionCtx);
                }
            } else {
                onionBtn.classList.remove('text-blue-400');
                onionText.innerText = 'Onion Skin: Off';
                onionCanvas.style.opacity = '0';
                onionCtx.clearRect(0, 0, onionCanvas.width, onionCanvas.height);
            }
        });

        // --- Dessin ---

        activeCanvas.addEventListener('pointerdown', (e) => {
            isDrawing = true;
            currentStroke = {
                color: currentTool === 'eraser' ? '#ffffff' : currentColor,
                isEraser: currentTool === 'eraser',
                points: []
            };
            addPoint(e);
        });

        window.addEventListener('pointermove', (e) => {
            if (!isDrawing) return;
            addPoint(e);
            drawCurrentStroke();
        });

        window.addEventListener('pointerup', () => {
            if (isDrawing && currentStroke.points.length > 0) {
                allStrokes.push(currentStroke);

                // If onion skin is enabled, update it to include the new stroke
                if (isOnionSkinEnabled && !currentStroke.isEraser) {
                    // Add the new stroke to onion canvas
                    onionCtx.beginPath();
                    onionCtx.strokeStyle = currentStroke.color;
                    onionCtx.lineWidth = 3;
                    onionCtx.lineCap = 'round';
                    onionCtx.lineJoin = 'round';

                    let first = true;
                    for (let i = 0; i < currentStroke.points.length; i++) {
                        const p = currentStroke.points[i];
                        if (first) {
                            onionCtx.moveTo(p.x, p.y);
                            first = false;
                        } else {
                            onionCtx.lineTo(p.x, p.y);
                        }
                    }
                    onionCtx.stroke();
                }
            }
            isDrawing = false;
            currentStroke = null;
        });

        function addPoint(e) {
            const rect = activeCanvas.getBoundingClientRect();
            currentStroke.points.push({
                x: e.clientX - rect.left,
                y: e.clientY - rect.top,
                t: Date.now() - startTime
            });
        }

        function drawCurrentStroke() {
            if (!currentStroke || currentStroke.points.length < 2) return;

            activeCtx.beginPath();
            activeCtx.strokeStyle = currentStroke.color;
            activeCtx.lineWidth = currentStroke.isEraser ? 20 : 3;
            activeCtx.lineCap = 'round';
            activeCtx.lineJoin = 'round';

            const pts = currentStroke.points;
            activeCtx.moveTo(pts[pts.length - 2].x, pts[pts.length - 2].y);
            activeCtx.lineTo(pts[pts.length - 1].x, pts[pts.length - 1].y);
            activeCtx.stroke();
        }

        // --- Boucle de rendu ---

        function loop() {
            const now = Date.now();
            let elapsed = now - startTime;

            // Gestion de la fin du cycle
            if (elapsed >= cycleDuration) {
                currentCycleIndex++;
                initCycle();
                elapsed = 0;
            }

            // Mise à jour UI
            const progress = (elapsed / cycleDuration) * 100;
            progressBar.style.width = progress + '%';

            // Rendu du Replay (Vidéo des cycles précédents - animated)
            renderReplay(elapsed);

            requestAnimationFrame(loop);
        }

        // Render time-based animation (current cycle playing back)
        function renderReplay(elapsed) {
            replayCtx.clearRect(0, 0, replayCanvas.width, replayCanvas.height);

            replayCtx.lineCap = 'round';
            replayCtx.lineJoin = 'round';

            allStrokes.forEach(stroke => {
                replayCtx.beginPath();
                replayCtx.strokeStyle = stroke.color;
                replayCtx.lineWidth = stroke.isEraser ? 20 : 3;

                let first = true;
                for (let i = 0; i < stroke.points.length; i++) {
                    const p = stroke.points[i];

                    // On ne dessine le point que si son temps correspond au temps écoulé du cycle
                    if (p.t <= elapsed) {
                        if (first) {
                            replayCtx.moveTo(p.x, p.y);
                            first = false;
                        } else {
                            replayCtx.lineTo(p.x, p.y);
                        }
                    }
                }
                replayCtx.stroke();
            });
        }

        // --- Contrôles ---

        durationSlider.addEventListener('input', (e) => {
            cycleDuration = e.target.value * 1000;
            durationVal.innerText = e.target.value + 's';
        });

        clearBtn.addEventListener('click', () => {
            allStrokes = [];
            currentCycleIndex = 1;
            onionCtx.clearRect(0, 0, onionCanvas.width, onionCanvas.height);
            initCycle();
        });

        // Lancement
        initCycle();
        loop();

    </script>
</body>
</html>